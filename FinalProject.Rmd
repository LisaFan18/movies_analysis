---
title: "Movie Dataset Analysis"
author: "Juan"
date: "4/8/2018"
output: 
  html_document:
    toc: yes
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE)
```

# 1. Load packages
```{r loadpackage}
library(tidyverse)
library(magrittr)
library(dplyr)
library(readr)
library(tidytext)
library(jsonlite)
library(wordcloud)
library(stringr)
library(formattable)
library(ggrepel)
```

# 2. Introduction

## 2.1 Background
IMDB and TMDB are the most popular movie datasets. This project is going to explore them and try to get some insights. 

It could help us to answer some questions like are Jan-Feb Hollywood "Dump Months", who are the Top 5 writers based on movie score/profit,what are high frequency words in tagline and so on. 

Besides, I build a shiny application for searching interested moives. 

## 2.2 Data Description {.tabset .tabset-fade}
### TMDB Movie dataset 
TMDB movies dataset is from kaggle: https://www.kaggle.com/tmdb/tmdb-movie-metadata/data. It contains two files:tmdb_5000_movies.csv and tmdb_5000_credits.csv.

From the glimpse, movies dataset contains 4803 observations and 20 variables; credits dataset has 4 variables: movie_id, title, cast and crew. The following analysis is not related to the "cast" variable. Besides "tmdb_5000_credits.csv" size is more than 25 MB (file size limit on github). Thus, I save a tidy version of credit dataset to "tmdb_5000_credits_tidy.csv".

```{r load_tmdb, echo = FALSE}
tmdb.raw <- read_csv("./data/tmdb_5000_movies.csv") 
glimpse(tmdb.raw)
#summary(tmdb.raw)
tmdb.credit.raw <- read_csv("./data/tmdb_5000_credits_tidy.csv")
#glimpse(tmdb.credit.raw)
#summary(tmdb.credit.raw)
```

### IMDB Movie dataset
IMDB movies dataset is from data.world: https://data.world/data-society/imdb-5000-movie-dataset. For consistancy, I change the file name from "movie_metadata.csv" to "imdb_5000_movies.csv". It contains 5043 observations and 28 variables according to the glimpse.

```{r load_imdb, echo = FALSE}
imdb.raw <- read_csv("./data/imdb_5000_movies.csv") 
glimpse(imdb.raw)
#summary(imdb.raw)
```


# 3. Data cleaning

## 3.1 Clean TMDB dataset

Select some columns I am interested in and generate a new data.frame. Some columns in TMDB dataset are in JSON format. I use jsonlite library to extract the data. 

```{r clean_tmdb_movies, echo = FALSE}
# retrieve the interested columns
tmdb <- tmdb.raw %>% 
  select(id, release_date, original_title, genres, runtime, budget, revenue,tagline, production_companies,vote_average) %>% 
  mutate(profit = revenue - budget) %>% 
  rename("title" = "original_title", "score" = "vote_average")
```

## 3.2 Clean IMDB dataset

IMDB dataset has 45 (`sum(duplicated(imdb.raw)`) duplicate observations. First, let's delete them. Then retrieve the interested variables and tidy up. 

```{r clean_imdb_rmduplicate}
sum(duplicated(imdb.raw))
```

```{r clean_imdb, echo=FALSE}
# remove the duplicate rows
imdb.raw <- imdb.raw[!duplicated(imdb.raw), ]
imdb <- imdb.raw %>% 
  select(title_year, movie_title, director_name, genres, actor_1_name, actor_2_name, actor_3_name, movie_imdb_link, plot_keywords, budget, gross, imdb_score) %>% 
  rename("year" = "title_year", "title" = "movie_title", "director" = "director_name", "imdb_link" = "movie_imdb_link")
```

## 3.3 Join TMDB and IMDB
I design a shiny application in [section 6](#section6) for searching your interested movies. The data in the shiny application is generated by joining TMDB and IMDB movies datasets. 

At first, I try to inner_join() the two movies datasets by "title". Unfortunately, the result of joining is empty. 

Use `sample(imdb.raw$title, 10)` to find that all the IMDB movie titles have a whitespace at the end. This might be generated during the data collection. 

Use the str_trim() function to remove them before doing the join operation.
```{r join_tmdb_imdb_trimtitle}
sample(imdb.raw$movie_title, 10)
```

```{r join_tmdb_imdb,echo=FALSE}
imdb <- mutate(imdb, title=str_trim(title))
# inner_join
movies.shiny <- tmdb %>% 
  select(title, runtime, score) %>% 
  inner_join(imdb, by = c("title" = "title")) %>% 
  select(title, year, director, genres, actor_1_name, actor_2_name,actor_3_name, plot_keywords, runtime, score, imdb_link)

movies.shiny <- movies.shiny[!duplicated(movies.shiny), ]

# anti_join
# tmdb %>% select(title) %>% anti_join(select(imdb, title), by = c("title" = "title"))
#imdb %>% select(title) %>% anti_join(select(tmdb, title), by = c("title" = "title"))
```

# 4. Explore the Data

## 4.1 Explore Release date

There is a popular belief that Jan-Feb is termed as dump months among the hollywood film industry.   [This blog](https://uproxx.com/movies/why-january-is-movie-dump-month/ ) offered several reasons to support this belief. 

Let's see what evidence I can find in our dataset either for or against the theory? 

### 4.1.1 tidy the data

In this section, I am exploring TMDB dataset as IMDB dataset doesn't provide the months of released movies. 

Since there are only 2 movies released in 2017, I filter them out. 

```{r explr_releasedate_tidy, echo=FALSE}
# split the release_date 
movies <- tmdb %>% separate(release_date, c("year", "month", "day"), convert = TRUE) %>% 
  filter(year!=2017)
#movies %>% count(year, sort = TRUE) %>% arrange(desc(year))
#movies %>% count(year, sort = TRUE) %>% arrange(year)
```

### 4.1.2 which year has the maximum released movies? 
```{r explr_releasedate_q1, echo=FALSE}
movies %>% group_by(year) %>% 
  drop_na(year) %>% 
  summarise(count=n()) %>% 
  arrange(desc(year)) %>%
  ggplot(aes(year, count)) +
  geom_point() +
  geom_line() + 
  ggtitle("Total Number of Released Movies per Year") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Year") + 
  ylab("Number") 
```

From the above figure, I can see that the film industry has been explorsive growth in the last thirty years. 2009 has the maximum released movies. 

Has the rising release brought in the rising revenue? Let's check it. 

### 4.1.3 does the number of released movies correlate with its revenue? 

```{r explr_releasedate_q2, echo=FALSE}
movies %>% group_by(year) %>% 
  drop_na(year) %>% 
  summarise(count=sum(revenue, na.rm = TRUE)) %>% 
  arrange(desc(year)) %>%
  ggplot(aes(year, count)) +
  geom_point() +
  geom_line() + 
  ggtitle("Total Revenue of Released Movies per Year") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Year") + 
  ylab("Revenue") 
```

From 1997 to 2017, despite the number of released movies per year experienced three major fluctuations, the revenue is on the rising. 

Based on this, I might could make this conclusion: the film market is becoming mature and has relatively fixed consumer groups. Thus, the movies industry would be a good investment option. 

### 4.1.4 are Jan-Feb Hollywood "Dump Months" ?
```{r explr_releasedate_q3, echo=FALSE}
movies %>% group_by(month) %>% 
  drop_na(month) %>% 
  summarise(count=n()) %>% 
  arrange(desc(month)) %>%
  ggplot(aes(reorder(month,count),count,fill=month)) +
  geom_bar(stat="identity") +
  geom_label(aes(label=count)) + 
  ggtitle("Total Number of Released Movies per Month") + 
  theme(plot.title = element_text(hjust = 0.5), legend.position="none") + 
  xlab("Month") + 
  ylab("Number") +
  coord_flip()
```

From the barplot, it is founded that Feburary has the minimum release. This is line with the "Dump Month" theory. However, the number of released movies in January ranks in the middle. This might be explained by the delay effect since January is followed by December. 

At the same time, I notice that the top 3 months are September, October and December. In other words, a large number of movies are released at the end of the year. 

Here's a good description:  

"This is due in large part to the effect of the Academy Awards (aka the Oscars).  In order for a film to be considered for the 2016 Oscars, it needs to have been on general release before 31st December 2015.  Studios want to have their best films in the forefront of Oscar membersâ€™ minds when they are considering who to vote for in January.  This means that a large number of Oscar-nominated films are released at the end of the year. " Cited from [this article](https://stephenfollows.com/hollywood-dump-months/)

## 4.2 Explore movies genres 

Let's move into movies genres. The genre column are JSON format and I use the the jsonlite library to convert it into proper format. This code is inspired from [here](https://www.kaggle.com/epfreed/tidydata-movie-dataset-exploration/notebook).

### 4.2.1 tidy the data
```{r explr_genere_tidy}
genre.df <- movies %>%
  filter(nchar(genres) > 2) %>% 
  mutate(jsn=lapply(genres,fromJSON)) %>% 
  unnest(jsn) %>% 
  select(year, month, title, id, genre=name) 
```

### 4.2.2 wordcloud of the genre

I think [word cloud](http://www.sthda.com/english/wiki/text-mining-and-word-cloud-fundamentals-in-r-5-simple-steps-you-should-know) is a very appearing visualization way. Finally, I can use it in here.   

Which genres are more popular? Let's find it by generating a word cloud of movies genres. 
```{r explr_genere_q1, echo=FALSE}
wd.genre <- genre.df %>%
  group_by(genre) %>%
  summarise(count = length(genre)) %>%
  arrange(desc(count))
# visualization
wordcloud(words = wd.genre$genre, freq = wd.genre$count,
          min.freq = 1, max.words = 20,
          random.order = FALSE, random.color = FALSE, 
          rot.per = 0.35, colors = brewer.pal(8, "Dark2"))
```

The above word cloud clearly shows that "Drama", "Comedy", "Thriller", "Action" and "Romance" are the 5 most popular genres. 

As there are 20 genres in total. For the better visualization, the following analysis would focus on the top 4 genres: "Drama", "Comedy", "Thriller" and "Action".

### 4.2.3 is the movies genre related to its release month?
```{r explr_genere_q2, echo=FALSE}
genre.df %>%
  filter(genre %in% c("Drama", "Comedy", "Thriller", "Action")) %>%
  group_by(month, genre) %>%
  drop_na(month, genre) %>%
  summarise(count = n()) %>%
  ggplot(aes(reorder(month, count), count, fill = genre)) +
  geom_bar(stat = "identity") +
  ggtitle("Movies Genre and Release Month") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Month") +
  ylab("Number") +
  facet_wrap( ~ genre)
```

From the above plots, I can find that the movies genre is not related to its release month! Especially for Action and Comedy movies, the release number appears a uniform distribution under the 12 months. 

In general, September has the maximum release. This agrees with the figure of "Total Number of Released Movies per Month".

### 4.2.4 which month has the minimum Thriller ?

The Thriller subplot clearly shows that December has the minimum of released thriller movies. It makes sense! Because both Christmas and New Years are in December. Most people tend not watch Thriller in festive season. 

## 4.3 Explore plot_keywords

I want to discover how original are Hollywood movies? The "plot_keywords" column in IMDB dataset can give us some ideas. 

### 4.3.1 tidy the data

First, let's label the movie as "original" or "adapted" according to the "plot_keywords" column. If "plot_keywords" contains "based on novel", I label it "adapted", otherwise "original". 

```{r explr_material_tidy, echo=FALSE}
material.df <- imdb %>% 
  select(title, plot_keywords, gross, budget) %>% 
  drop_na(plot_keywords) %>% 
  mutate(material = if_else(str_detect(plot_keywords, "based on novel"), "adapted", "original"))
```

### 4.3.2 how original are hollywood movies? 
```{r explr_material_q1, echo=FALSE}
material.df %>% 
  select(material) %>% 
  group_by(material) %>% 
  summarise(n=n()) %>% 
  ungroup() %>% 
  mutate(per=`n`/sum(`n`)) %>% 
  arrange(per) %>% 
  mutate(label = scales::percent(per)) %>% 
  ggplot() +
  geom_bar(aes(x="", y=per, fill=material), stat="identity", width = 1) +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(aes(x=1, y = cumsum(per) - per/2, label=label))
```

This visualization approach is cited by [here](https://stackoverflow.com/questions/45657990/how-to-create-a-pie-chart-with-percentage-labels-using-ggplot2?rq=1). 

The pie chart clearly shows that original movies takes the most part. Thus, it's reasonably inferred that movie writer plays an very important role in filmmaking. To find out who are the most successful writer in Hoolywood, I will explore the movies writer in the next section. 

Before that, I would keep on comparing the original with adapted movies. 

### 4.3.3 are adapted movies more profitable than original movies? {.tabset .tabset-fade}
```{r explr_material_q2, echo=FALSE}
material.df %>% 
  select(material, budget, gross) %>% 
  drop_na(budget, gross) %>% 
  mutate(profit = gross - budget) %>% 
  group_by(material) %>% 
  summarise(average_profit = format(mean(profit), digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  formattable(align=c("l","c"))
```

Yes, the adapted movies are more profitable than original movies. 
Why? Maybe the adapted movies are more likely to present a good story?  Let's check what the top 10 profitable adapted movies are and verify the conclusion.  

#### Top 10 adapted movies in IMDB based on profit
```{r explr_material_q3a, echo=FALSE}
material.df %>% 
  select(title, material, budget, gross) %>% 
  filter(material == "adapted") %>% 
  drop_na(budget, gross) %>% 
  mutate(profit = format((gross - budget), digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  arrange(desc(profit)) %>% 
  select(-material) %>% 
  top_n(10) %>% 
  select(title, profit) %>% 
  formattable(align=c("l","c"))
```

It's surpurising to find that most profit is negative. Let's check the profit of original movies.

#### Top 10 profitable original movies in IMDB
```{r explr_material_q3b, echo=FALSE}
material.df %>% 
  select(title, material, budget, gross) %>% 
  filter(material == "original") %>% 
  drop_na(budget, gross) %>% 
  mutate(profit = format((gross - budget), digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  arrange(desc(profit)) %>% 
  select(-material) %>% 
  top_n(10) %>% 
  select(title, profit) %>% 
  formattable(align=c("l","c"))
```

All profit of original movies are negative. This does not make sense at all. Let's check the movie profit in TMDB dataset. 

#### Top 10 profitable movies in TMDB

```{r explr_material_q3c, echo=FALSE}
tmdb %>% 
  select(title, profit) %>% 
  drop_na(profit) %>% 
  mutate(profit = format(profit, digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  arrange(desc(profit)) %>% 
  top_n(10) %>% 
  formattable(align=c("l","c"))
```

Then I try to find out the reason. On the IMDB help website, there is a question: "Why are your budget/gross figures for some movies different than those listed by another source? "
[Here](https://help.imdb.com/article/imdb/discover-watch/why-are-your-budget-gross-figures-for-some-movies-different-than-those-listed-by-another-source/GCS37LSKVDMU37LV?ref_=helpart_nav_14#) is the answer

Meanwhile, I recheck the TMDB data source and find this [description](https://www.kaggle.com/tmdb/tmdb-movie-metadata): 

"The revenues appear to be more current. For example, IMDB's figures for Avatar seem to be from 2010 and understate the film's global revenues by over $2 billion."

Thus, let's revise the question: are adapted movies more profitable than original movies? according to the profit data in TMDB dataset. 

```{r explr_material_q2_revise, echo=FALSE}
new.material.df <- tmdb %>% 
  select(title, profit, budget) %>% 
  drop_na(profit) %>% 
  inner_join(select(material.df, title, material)) 

#sum(duplicated(new.material.df))
new.material.df <- new.material.df[!duplicated(new.material.df), ]

new.material.df %>% 
  group_by(material) %>% 
  summarise(average_profit = format(mean(profit), digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  formattable(align=c("l","c"))
```

No, adapted movies is less profitable than original movies. When Hollywood adapted a beloved novel for the screen, most readers always think "The book is better than the movie."

This supports one of previous conclusions: movie writer plays an very important role in filmmaking. 


### 4.3.4 Top 10 most profitable adapted movies in TMDB
```{r explr_material_q4, echo=FALSE}
new.material.df %>% 
  filter(material == "adapted") %>% 
  select(title, material, profit) %>% 
  arrange(desc(profit)) %>% 
  select(-material) %>% 
  top_n(10) %>% 
  mutate(profit = format(profit, digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  formattable(align=c("l","c"))
```

### 4.3.5 Profit VS. Budget of Top 30 most Profitable adapted Movies

Since all adapted movies have high quality stories. I am wondering how does the adapted movies budget affect its profit ? Let's explore it in the top 30 most profitable adapted movies. 

The below plot shows that high budget movies tend to earn more profit. The relationship between budget and profit is almost linear.
```{r explr_material_q5, echo=FALSE}
new.material.df %>% 
  filter(material == "adapted") %>% 
  select(title, material, profit, budget) %>% 
  arrange(desc(profit)) %>% 
  select(-material) %>% 
  top_n(30, profit) %>%
  ggplot(aes(x=budget/1000000, y=profit/1000000)) +
  geom_point() +
  geom_smooth() + 
  geom_text_repel(aes(label=title)) +
  labs(x = "Budget ($million)", y = "Profit ($million)", title = "Profit VS. Budget of Top 30 most Profitable adapted Movies") +
  theme(plot.title = element_text(hjust = 0.5))
```



## 4.4 Explore movies writer {.tabset .tabset-fade}

Now, it's the time to explore the movies writer. The "crew" column in the TMDB credit dataset contains the writer of each movie. 

* First, as the "crew" column is in JSON format, let's tidy it up by the way similar to genre
* Then, join "credit" with "movie"" in TMDB dataset. 
* Joining them by "id" would be faster than by "title" since the length of "id" is shorter.

```{r explr_writer_tidy, echo=FALSE}
writer.df <- tmdb.credit.raw %>% 
  filter(nchar(crew)>2) %>% 
  mutate(js=lapply(crew,fromJSON)) %>% 
  unnest(js) %>% 
  select(movie_id, title, job, name) %>% 
  filter(job == "Writer") %>% 
  dplyr::rename("writer" = "name") %>% 
  select(movie_id, title, writer) %>% 
  inner_join(filter(select(tmdb, id, profit, score), !is.na(profit)), by=c("movie_id" = "id"))
```

### 4.4.1 who are the Top 5 writers based on movie score
```{r explr_writer_q1, echo=FALSE}
writer.df %>% 
  group_by(writer) %>% 
  summarise(average_score = mean(score)) %>% 
  arrange(desc(average_score)) %>%
  select(writer, average_score) %>% 
  top_n(5) %>% 
  formattable(align=c("l","c"))
```

### 4.4.2 who are the Top 5 writers based on profit
```{r explr_writer_q2, echo=FALSE}
writer.df %>% 
  group_by(writer) %>% 
  summarise(average_profit = mean(profit)) %>% 
  arrange(desc(average_profit)) %>%
  select(writer, average_profit) %>% 
  top_n(5) %>% 
  mutate(average_profit = format(average_profit, digits=9, decimal.mark=",", big.mark=",", small.mark=".", small.interval=3)) %>% 
  formattable(align=c("l","c"))
```

## 4.5 Explore production companies {.tabset .tabset-fade}

Covert "production_companies" into data.frame similar to genre.
Use the formattable package to achieve a better visualization. 

From the following three tables, I found an interesting phenomenon: 

"Warner Bros.", "Universal Pictures", "Paramount Pictures" and "Twentieth Century Fox Film Corporation	222" have the most release and revenue. However, they are not listed in the top 10 profitable companies.

I could provide a reasonable explanation for this: as independent films that become more popular,  you donâ€™t necessarily need big budgets to get big returns in the movie world. There are many good examples such as "Little Miss Sunshine", "The Kingâ€™s Speech"", "Lost in Thailand". 

```{r explr_company_tidy, echo=FALSE}
company.df <- movies %>% 
  filter(nchar(production_companies)>2) %>% 
  mutate(js=lapply(production_companies,fromJSON)) %>% 
  unnest(js) %>% 
  select(budget,revenue,company=name)
```

### 4.5.1 Top 10 companies based on release
```{r explr_company_q1, echo=FALSE}
company.df %>% 
  group_by(company) %>% 
  summarise(count=n()) %>% 
  arrange(desc(count)) %>% 
  top_n(10) %>% 
  formattable(align=c("l","c"),list(count=color_bar('lightgreen')))
```


### 4.5.2 Top 10 companies based on revenue

```{r explr_company_q2, echo=FALSE} 
company.df %>% 
  group_by(company) %>% 
  summarise(`revenue (billion USD)` = format(sum(revenue, na.rm = FALSE)/1000000000, digits = 3, nsmall = 2, scientific = FALSE)) %>% 
  arrange(desc(`revenue (billion USD)`)) %>% 
  top_n(10) %>% 
  formattable(align=c("l","c"),list(`revenue (million USD)`=color_bar('lightblue')))
```


### 4.5.3 Top 10 companies based on profit

```{r explr_company_q3, echo=FALSE} 
company.df %>% 
  mutate(profit = revenue - budget) %>% 
  group_by(company) %>% 
  summarise(`profit (billion USD)` = format(sum(profit, na.rm = FALSE)/1000000000,digits = 3, scientific = FALSE)) %>% 
  arrange(desc(`profit (billion USD)`)) %>% 
  top_n(10) %>% 
  formattable(align=c("l","c"),list(`profit (billion USD)`=color_bar('orange')))
```

# 5. Text analysis on tagline {.tabset .tabset-fade}

Have you heard about these taglines?  "In space no one can hear you scream". "Man is the warmest place to hide". "Family isn't a word. It's a sentence". These tagline are so memorable and precisely capture the spirit of the movie. 
 
Let's explore what are high frequency words the movie marketers would like to use. Tidy the "tagline" column in TMDB dataset. 

The following two barplots clearly shows that: 
* "love", "life", "story", "world" and "family" are the most 5 frequent words in tagline.
* "love story", "motion picture" and "romantic comedy" are the top 3 most frequent pair words in tagline.

This supports that the most 2 popular movie genre are "Drama" and "Comedy" .

```{r explr_tagline_tidy, echo=FALSE}
movies.tagline <- tmdb %>% 
  select(tagline) %>% filter(!is.na(tagline)) 
```

## 5.1 high frequency words
```{r explr_tagline_q1, echo=FALSE}
movies.tagline %>% 
  unnest_tokens(word, tagline) %>% 
  anti_join(stop_words) %>%
  count(word, sort = TRUE) %>% 
  top_n(20) %>% 
  ggplot(aes(reorder(word,n),n,fill=word)) +
  geom_bar(stat = "identity") +
  geom_label(aes(label=n)) + 
  ggtitle("Top 20 High Frequency Word in Tagline") + 
  theme(plot.title = element_text(hjust = 0.5), legend.position="none") + 
  xlab(NULL) + coord_flip()
```

## 5.2 high frequency bi-grams
```{r explr_tagline_q2, echo=FALSE}
movies.tagline %>% 
  unnest_tokens(bigram, tagline, token = "ngrams", n = 2) %>% 
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stop_words$word) %>%
  filter(!word2 %in% stop_words$word) %>% 
  count(word1, word2, sort = TRUE) %>% 
  filter(n>5) %>% 
  unite("pairwords", c("word1", "word2"), sep = " ") %>% 
  ggplot(aes(reorder(pairwords,n),n,fill=pairwords)) +
  geom_bar(stat = "identity") +
  geom_label(aes(label=n)) + 
  ggtitle("High Frequency Bi-grams in Tagline") + 
  theme(plot.title = element_text(hjust = 0.5), legend.position="none") + 
  xlab(NULL) + coord_flip()
```

# 6. A shiny app for searching movies {#section6}

In most scenarios, I don't care about the actors' ranking but only care about whether the actor is casted in one movie. Therefore, I use the unite() function to combine three actors' names in one column. 

In the shiny app

  * use `str_detect(actors, input$actorInput)` to filter the actors' name chosen by the user. 
  * create a hyperlink to IMDB website in the "detail" column

In order to easily start up the shiny app, I save the data into  ["movies_shiny.csv"](https://github.com/LisaFan18/movies_analysis/blob/master/data/movies_shiny.csv). 

The shiny app.R is located [here](https://github.com/LisaFan18/movies_analysis/blob/master/app.R)
```{r shiny}
movies.shiny %>% 
  unite("actors", c("actor_1_name","actor_2_name","actor_3_name"), sep = "|" ) %>% 
  rename("plot" = "plot_keywords") %>% 
  write_csv("./data/movies_shiny.csv")
```

# 7. Conclusion

1. The most time-consuming parts of this projectï¼š
  * exploring the data, especially the plot_keywords
  * visualization 
  * present a reasonable explanation for the analysis result
2. To better visualization, I try some new tools: 
  * word cloud
  * pie chart
  * formattable package
3. To well-formed report, I try some new RMarkdown skills:
  * tabset
  * use internel link in RMarkdown HTML output
  * create a hypelinke in shiny renderDataTable 